{"name":"F77 zmq","tagline":"Fortran binding for ZeroMQ","body":"# F77\\_ZMQ\r\n\r\nA Fortran 77 binding library for [ZeroMQ](http://zeromq.org)\r\n\r\nThis binding works with [ZeroMQ 4.1.3](https://github.com/zeromq/zeromq4-1).\r\n\r\n## Usage\r\n\r\nCopy the `f77_zmq.h` and `libf77zmq.so` or `libf77zmq.a` files into\r\nyour project.\r\n\r\nIn your Fortran source files, include the `f77_zmq.h` file. This will define all the `ZMQ_*` constants.\r\nAll the pointers (to sockets, messages, polling items, etc) are defined as `integer(ZMQ_PTR)`\r\nin order to handle 32-bit or 64-bit pointers.\r\n\r\nIn your Makefile, compile as follows:\r\n\r\n```\r\n$(FC) -o $(TARGET) $(OBJ) -lzmq -lf77zmq \r\n```\r\n\r\nor\r\n\r\n```\r\n$(FC) -o $(TARGET) $(OBJ) -lzmq libf77zmq.a\r\n```\r\n\r\nBe sure that `libzmq.so.4` is present in your `LD_LIBRARY_PATH` before executing the program.\r\n\r\n\r\n\r\n## Installation instructions\r\n\r\n\r\nPython >= 2.6 is required to create the `f77_zmq.h` file.\r\n\r\nSet the `ZMQ_H` environment variable to the absolute path of the zmq.h file, and run make.\r\nThe default compiler is gcc.\r\n\r\nFor example:\r\n\r\n```\r\n$ export ZMQ_H=/usr/include/zmq.h\r\n$ make\r\n```\r\n\r\n## Differences with the C API\r\n\r\nIn Fortran77 structs don't exist. They have been introduced with Fortran90.\r\nTo maintain F77 compatibility, the structs are created using C functions\r\nand their pointers are passed to the Fortran. This implies the addition\r\nof a few functions.\r\n\r\n### Additional Message-related functions\r\n\r\n* `integer(ZMQ_PTR) f77_zmq_msg_new()` : Allocates a `zmq_msg_t` and returns the pointer\r\n\r\n* `integer f77_zmq_msg_destroy(msg)` : Deallocates the `zmq_msg_t`. Return value is `0`.\r\n\r\n  + `integer(ZMQ_PTR) msg` : message \r\n\r\n* `integer(ZMQ_PTR) f77_zmq_msg_data_new(size, buffer, size_buffer)` : Allocates a data\r\n  buffer for messages, and copies the buffer into the data segment. If `size_buffer` is `0`,\r\n  the data segement is uninitialized. The return value is a pointer to the data segment.\r\n\r\n  + `integer size` : Size of the data segment to allocate\r\n  + `buffer` : Buffer to copy. Fortran array or string.\r\n  + `integer size_buffer` : Number of bytes to copy from the buffer\r\n\r\n* `integer f77_zmq_msg_destroy_data(data)` : Deallocates a data segment. Return value is `0`.\r\n\r\n  + `integer(ZMQ_PTR) data` : pointer to the data segment to deallocate.\r\n\r\n* `integer f77_zmq_msg_copy_from_data(msg, buffer)` : Copies the data segment of a message \r\n  into a buffer.\r\n\r\n  + `integer(ZMQ_PTR) msg` : message\r\n  + `buffer` : fortran array of string\r\n\r\n* `integer f77_zmq_msg_copy_to_data(msg, buffer, size)` : Copies the data segment of a message \r\n  into a buffer.\r\n\r\n  + `integer(ZMQ_PTR) msg` : message\r\n  + `buffer` : fortran array of string\r\n  + `integer size` : Number of bytes to copy\r\n\r\n\r\n### Additional Polling-related functions\r\n\r\n* `integer(ZMQ_PTR) f77_zmq_pollitem_new()` : Allocates a `zmq_pollitem_t` and returns the pointer\r\n\r\n* `integer f77_zmq_pollitem_destroy(item)` : Deallocates the `zmq_pollitem_t`. Return value is `0`.\r\n\r\n  + `integer(ZMQ_PTR) item` : poll item struct\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}